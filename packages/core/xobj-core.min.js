var xobjCore=(function(exports){'use strict';function isNumberType(type) {
    switch (type) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
            return true;
        default:
            return false;
    }
}
function isIntegerType(type) {
    switch (type) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
            return true;
        default:
            return false;
    }
}
function isFloatType(type) {
    switch (type) {
        case 17:
        case 18:
            return true;
        default:
            return false;
    }
}
function isBooleanType(type) {
    switch (type) {
        case 6:
        case 5:
            return true;
        default:
            return false;
    }
}class BufferWriter {
    _data;
    _position;
    _length;
    _littleEndian;
    get littleEndian() {
        return this._littleEndian;
    }
    get length() {
        return this._length;
    }
    get bytesAvailable() {
        return this._length - this._position;
    }
    get position() {
        return this._position;
    }
    set position(value) {
        if (value < 0) {
            value = 0;
        }
        else if (value > this._length) {
            value = this._length;
        }
        this._position = value;
    }
    get buffer() {
        return this._data.buffer.slice(0, this._length);
    }
    get bufferSize() {
        return this._data.buffer.byteLength;
    }
    constructor(bufferSize = 1024, littleEndian = false) {
        this._data = new DataView(new ArrayBuffer(bufferSize));
        this._position = 0;
        this._length = 0;
        this._littleEndian = littleEndian;
    }
    allocate(bytes) {
        const targetSize = this._position + bytes;
        let size = this._data.buffer.byteLength;
        if (targetSize < size) {
            return;
        }
        while (size < targetSize) {
            size *= 2;
        }
        const buffer = new ArrayBuffer(size);
        const array = new Uint8Array(buffer);
        array.set(new Uint8Array(this._data.buffer));
        this._data = new DataView(buffer);
    }
    movePosition(value) {
        this._position += value;
        if (this._length < this._position) {
            this._length = this._position;
        }
    }
    writeUint8(value) {
        this.allocate(1);
        this._data.setUint8(this._position, value);
        this.movePosition(1);
    }
    writeUint16(value) {
        this.allocate(2);
        this._data.setUint16(this._position, value, this._littleEndian);
        this.movePosition(2);
    }
    writeUint32(value) {
        this.allocate(4);
        this._data.setUint32(this._position, value, this._littleEndian);
        this.movePosition(4);
    }
    writeUintVar(value) {
        let next = false;
        do {
            let byte = value & 0x7f;
            value /= 128;
            next = value >= 1;
            if (next) {
                byte |= 0x80;
            }
            this.writeUint8(byte);
        } while (next);
    }
    writeIntVar(value) {
        let sign = 0;
        if (value < 0) {
            value = -value;
            sign = 1;
        }
        let byte = ((value & 0x3f) << 1) | sign;
        value /= 64;
        const next = value >= 1;
        if (next) {
            byte |= 0x80;
        }
        this.writeUint8(byte);
        if (next) {
            this.writeUintVar(value);
        }
    }
    writeInt8(value) {
        this.allocate(1);
        this._data.setInt8(this._position, value);
        this.movePosition(1);
    }
    writeInt16(value) {
        this.allocate(2);
        this._data.setInt16(this._position, value, this._littleEndian);
        this.movePosition(2);
    }
    writeInt32(value) {
        this.allocate(4);
        this._data.setInt32(this._position, value, this._littleEndian);
        this.movePosition(4);
    }
    writeFloat32(value) {
        this.allocate(4);
        this._data.setFloat32(this._position, value, this._littleEndian);
        this.movePosition(4);
    }
    writeFloat64(value) {
        this.allocate(8);
        this._data.setFloat64(this._position, value, this._littleEndian);
        this.movePosition(8);
    }
    writeString(value) {
        this.writeUintVar(value.length);
        for (let i = 0; i < value.length; i++) {
            this.writeUintVar(value.charCodeAt(i));
        }
    }
    writeBigInt(value) {
        let sign = 1;
        if (value < 0) {
            sign = -1;
            value = -value;
        }
        let temp = value;
        let count = 0;
        while (temp) {
            temp >>= 8n;
            count++;
        }
        this.writeIntVar(sign * count);
        while (value) {
            const byte = value & 255n;
            this.writeUint8(Number(byte));
            value >>= 8n;
        }
    }
    writeBuffer(value) {
        this.writeUintVar(value.byteLength);
        this.allocate(value.byteLength);
        const array = new Uint8Array(this._data.buffer);
        array.set(new Uint8Array(value), this._position);
        this.movePosition(value.byteLength);
    }
    writeFlags(value) {
        let bitset = 0;
        for (let i = 0; i < value.length; i++) {
            if (value[i]) {
                bitset |= 2 ** i;
            }
        }
        this.writeUintVar(bitset);
    }
    writeBitset(value) {
        let bitset = 0;
        let position = 0;
        for (let i = 0; i < value.length; i++) {
            if (value[i]) {
                bitset |= 2 ** position;
            }
            position++;
            if (position === 8) {
                this.writeUint8(bitset);
                bitset = 0;
                position = 0;
            }
        }
        if (position) {
            this.writeUint8(bitset);
        }
    }
}class BufferReader {
    _data;
    _position;
    _littleEndian;
    get littleEndian() {
        return this._littleEndian;
    }
    get length() {
        return this._data.buffer.byteLength;
    }
    get bytesAvailable() {
        return this.length - this._position;
    }
    get position() {
        return this._position;
    }
    set position(value) {
        if (value < 0) {
            value = 0;
        }
        else if (value > this.length) {
            value = this.length;
        }
        this._position = value;
    }
    get buffer() {
        return this._data.buffer;
    }
    constructor(buffer, littleEndian = false) {
        this._data = new DataView(buffer);
        this._position = 0;
        this._littleEndian = littleEndian;
    }
    movePosition(value) {
        this._position += value;
    }
    readUint8() {
        const value = this._data.getUint8(this._position);
        this.movePosition(1);
        return value;
    }
    readUint16() {
        const value = this._data.getUint16(this._position, this._littleEndian);
        this.movePosition(2);
        return value;
    }
    readUint32() {
        const value = this._data.getUint32(this._position, this._littleEndian);
        this.movePosition(4);
        return value;
    }
    readUintVar() {
        let value = 0;
        let offset = 1;
        let byte = 0;
        do {
            byte = this.readUint8();
            value += (byte & 0x7f) * offset;
            offset *= 128;
        } while (byte & 0x80);
        return value;
    }
    readIntVar() {
        const byte = this.readUint8();
        const sign = byte & 1 ? -1 : 1;
        let value = (byte >>> 1) & 0x3f;
        if (byte & 0x80) {
            value += this.readUintVar() * 64;
        }
        return value * sign;
    }
    readInt8() {
        const value = this._data.getInt8(this._position);
        this.movePosition(1);
        return value;
    }
    readInt16() {
        const value = this._data.getInt16(this._position, this._littleEndian);
        this.movePosition(2);
        return value;
    }
    readInt32() {
        const value = this._data.getInt32(this._position, this._littleEndian);
        this.movePosition(4);
        return value;
    }
    readFloat32() {
        const value = this._data.getFloat32(this._position, this._littleEndian);
        this.movePosition(4);
        return value;
    }
    readFloat64() {
        const value = this._data.getFloat64(this._position, this._littleEndian);
        this.movePosition(8);
        return value;
    }
    readString() {
        let count = this.readUintVar();
        if (!count) {
            return '';
        }
        let value = '';
        if (count) {
            while (count--) {
                value += String.fromCharCode(this.readUintVar());
            }
        }
        return value;
    }
    readBigInt() {
        let count = this.readIntVar();
        let sign = 1n;
        if (count < 0) {
            count = -count;
            sign = -1n;
        }
        let value = 0n;
        let i = 0n;
        while (count--) {
            const byte = BigInt(this.readUint8());
            value |= byte << i;
            i += 8n;
        }
        return value * sign;
    }
    readBuffer() {
        const count = this.readUintVar();
        const value = this._data.buffer.slice(this._position, this._position + count);
        this.movePosition(value.byteLength);
        return value;
    }
    readFlags(count) {
        const value = this.readUintVar();
        const flags = [];
        for (let i = 0; i < count; i++) {
            flags.push(!!(value & (2 ** i)));
        }
        return flags;
    }
    readBitset(count) {
        const value = [];
        if (count) {
            let bitset = this.readUint8();
            let position = 0;
            while (count--) {
                value.push(!!(bitset & (2 ** position)));
                position++;
                if (position === 8 && count) {
                    bitset = this.readUint8();
                    position = 0;
                }
            }
        }
        return value;
    }
}function encodeAny(state, value) {
    const type = state.detect(state, value);
    if (type === 0) {
        throw `Unable to detect object type: ${value}`;
    }
    state.writer.writeUint8(type);
    const encoder = state.encoders.get(type);
    if (!encoder) {
        throw `Encoder method not found for object: ${value} with type: ${type}`;
    }
    encoder(state, value);
}
function initAnyEncoders(encoders) {
    encoders.set(1, encodeAny);
}function getStruct(state, value) {
    const struct = new Map();
    const keys = Object.keys(value);
    for (const key of keys) {
        const type = state.detect(state, value[key]);
        if (type === 22) {
            return undefined;
        }
        struct.set(key, type);
    }
    return struct;
}
function structsEqual(struct0, struct1) {
    if (struct0.size !== struct1.size) {
        return false;
    }
    for (const key in struct0.keys()) {
        if (struct0.get(key) !== struct1.get(key)) {
            return false;
        }
    }
    return true;
}
function getItemsStruct(state, items) {
    const groupStruct = getStruct(state, items[0]);
    if (groupStruct) {
        for (let i = 1; i < items.length; i++) {
            const itemStruct = getStruct(state, items[i]);
            if (!itemStruct || !structsEqual(groupStruct, itemStruct)) {
                return undefined;
            }
        }
    }
    return groupStruct;
}
function encodeStructInfo(state, struct) {
    const { writer } = state;
    writer.writeUintVar(struct.size);
    for (const property of struct) {
        const [name, type] = property;
        writer.writeString(name);
        writer.writeUint8(type);
    }
}
function encodeStruct(state, struct, value) {
    const { encoders } = state;
    for (const property of struct) {
        const [name, type] = property;
        const encoder = encoders.get(type);
        if (!encoder) {
            throw `Encoder method not found for object type: ${type} in struct encoding`;
        }
        encoder(state, value[name]);
    }
}function detectArray(state, value) {
    if (Array.isArray(value)) {
        return 21;
    }
    return 0;
}
function optimizeStructs(state, groups) {
    for (const group of groups) {
        if (group.type === 22) {
            group.struct = getItemsStruct(state, group.items);
            if (group.struct) {
                group.type = 23;
            }
        }
    }
}
function optimizeGroups(groups) {
    for (let i = 0; i < groups.length - 1; i++) {
        const j = i + 1;
        const group0 = groups[i];
        const group1 = groups[j];
        if (group0.type === 1 || group0.items.length === 1) {
            if (group1.items.length === 1) {
                group0.type = 1;
                group0.items.push(...group1.items);
                groups.splice(j, 1);
                i--;
            }
        }
    }
}
function getArrayGroups(state, value) {
    const groups = [];
    if (value.length) {
        const first = value[0];
        let group = { type: state.detect(state, first), items: [first] };
        groups.push(group);
        for (let i = 1; i < value.length; i++) {
            const item = value[i];
            const type = state.detect(state, item);
            if (group.type === type) {
                group.items.push(item);
            }
            else if (isBooleanType(group.type) && isBooleanType(type)) {
                group.items.push(item);
            }
            else if (isIntegerType(group.type) && isIntegerType(type)) {
                group.type = 16;
                group.items.push(item);
            }
            else {
                group = { type: state.detect(state, item), items: [item] };
                groups.push(group);
            }
        }
        optimizeStructs(state, groups);
        optimizeGroups(groups);
    }
    return groups;
}
function encodeArray(state, value) {
    const { writer, encoders } = state;
    const groups = getArrayGroups(state, value);
    writer.writeUintVar(groups.length);
    for (const group of groups) {
        writer.writeUint8(group.type);
        writer.writeUintVar(group.items.length);
        if (isBooleanType(group.type)) {
            writer.writeBitset(group.items);
        }
        else if (group.type === 23) {
            const { struct } = group;
            encodeStructInfo(state, struct);
            for (const item of group.items) {
                encodeStruct(state, struct, item);
            }
        }
        else {
            const encoder = encoders.get(group.type);
            if (!encoder) {
                throw `Encoder method not found for object type: ${group.type} in array encoding`;
            }
            for (const item of group.items) {
                encoder(state, item);
            }
        }
    }
}
function initArrayEncoders(encoders, detectors) {
    encoders.set(21, encodeArray);
    detectors.push(detectArray);
}function detectBoolean(state, value) {
    if (typeof value === 'boolean') {
        return value ? 6 : 5;
    }
    return 0;
}
function initBooleanEncoders(encoders, detectors) {
    encoders.set(6, () => { });
    encoders.set(5, () => { });
    detectors.push(detectBoolean);
}function detectEmpty(state, value) {
    if (typeof value === 'undefined') {
        return 3;
    }
    if (value === null) {
        return 2;
    }
    return 0;
}
function initEmptyEncoders(encoders, detectors) {
    encoders.set(3, () => { });
    encoders.set(2, () => { });
    detectors.push(detectEmpty);
}function detectMap(state, value) {
    if (value instanceof Map) {
        return 25;
    }
    return 0;
}
function encodeMap(state, value) {
    const keys = [...value.keys()];
    keys.sort();
    const values = [];
    for (const key of keys) {
        values.push(value.get(key));
    }
    encodeArray(state, keys);
    encodeArray(state, values);
}
function initMapEncoders(encoders, detectors) {
    encoders.set(25, encodeMap);
    detectors.push(detectMap);
}function detectNumber(state, value) {
    if (typeof value !== 'number') {
        return 0;
    }
    if (isNaN(value)) {
        return 4;
    }
    if (value === Number.POSITIVE_INFINITY) {
        return 7;
    }
    if (value === Number.NEGATIVE_INFINITY) {
        return 8;
    }
    if (Number.isInteger(value)) {
        if (value < 0) {
            if (value >= -0x80) {
                return 13;
            }
            if (value >= -0x8000) {
                return 14;
            }
            if (value >= -0x8000_0000) {
                return 15;
            }
            if (value >= -Number.MAX_SAFE_INTEGER) {
                return 16;
            }
        }
        if (value <= 0xff) {
            return 9;
        }
        if (value <= 0xffff) {
            return 10;
        }
        if (value <= 0xffff_ffff) {
            return 11;
        }
        if (value <= Number.MAX_SAFE_INTEGER) {
            return 12;
        }
    }
    else if (value.toString(10).length < 10) {
        return 17;
    }
    return 18;
}
function initNumberEncoders(encoders, detectors) {
    encoders.set(4, () => { });
    encoders.set(7, () => { });
    encoders.set(8, () => { });
    encoders.set(9, (state, value) => state.writer.writeUint8(value));
    encoders.set(10, (state, value) => state.writer.writeUint16(value));
    encoders.set(11, (state, value) => state.writer.writeUint32(value));
    encoders.set(12, (state, value) => state.writer.writeUintVar(value));
    encoders.set(13, (state, value) => state.writer.writeInt8(value));
    encoders.set(14, (state, value) => state.writer.writeInt16(value));
    encoders.set(15, (state, value) => state.writer.writeInt32(value));
    encoders.set(16, (state, value) => state.writer.writeIntVar(value));
    encoders.set(17, (state, value) => state.writer.writeFloat32(value));
    encoders.set(18, (state, value) => state.writer.writeFloat64(value));
    detectors.push(detectNumber);
}function detectObject(state, value) {
    if (typeof value === 'object') {
        return 22;
    }
    return 0;
}
function encodeObject(state, value) {
    const { writer, encoders } = state;
    const keys = Object.keys(value);
    writer.writeUintVar(keys.length);
    const encoder = encoders.get(1);
    if (!encoder) {
        throw `Encoder method not found for object type: ${1} in object encoding`;
    }
    for (const key of keys) {
        writer.writeString(key);
        encoder(state, value[key]);
    }
}
function initObjectEncoders(encoders, detectors) {
    encoders.set(22, encodeObject);
    detectors.push(detectObject);
}function detectSet(state, value) {
    if (value instanceof Set) {
        return 24;
    }
    return 0;
}
function encodeSet(state, value) {
    const array = [...value.values()];
    encodeArray(state, array);
}
function initSetEncoders(encoders, detectors) {
    encoders.set(24, encodeSet);
    detectors.push(detectSet);
}function detectString(state, value) {
    if (typeof value === 'string') {
        return 20;
    }
    return 0;
}
function initStringEncoders(encoders, detectors) {
    encoders.set(20, (state, value) => state.writer.writeString(value));
    detectors.push(detectString);
}function detectArrayBuffer(state, value) {
    if (value instanceof ArrayBuffer) {
        return 26;
    }
    return 0;
}
function encodeArrayBuffer(state, value) {
    const { writer } = state;
    writer.writeBuffer(value);
}
function initArrayBufferEncoders(encoders, detectors) {
    encoders.set(26, encodeArrayBuffer);
    detectors.push(detectArrayBuffer);
}function detectTypedArray(state, value) {
    if (value instanceof Uint8ClampedArray) {
        return 27;
    }
    if (value instanceof Uint8Array) {
        return 27;
    }
    if (value instanceof Uint16Array) {
        return 27;
    }
    if (value instanceof Uint32Array) {
        return 27;
    }
    if (value instanceof Int8Array) {
        return 27;
    }
    if (value instanceof Int16Array) {
        return 27;
    }
    if (value instanceof Int32Array) {
        return 27;
    }
    if (value instanceof Float32Array) {
        return 27;
    }
    if (value instanceof Float64Array) {
        return 27;
    }
    if (value instanceof DataView) {
        return 27;
    }
    return 0;
}
function encodeTypedArray(state, value) {
    const { writer } = state;
    if (value instanceof Uint8ClampedArray) {
        writer.writeUint8(9);
    }
    if (value instanceof Uint8Array) {
        writer.writeUint8(9);
    }
    if (value instanceof Uint16Array) {
        writer.writeUint8(10);
    }
    if (value instanceof Uint32Array) {
        writer.writeUint8(11);
    }
    if (value instanceof Int8Array) {
        writer.writeUint8(13);
    }
    if (value instanceof Int16Array) {
        writer.writeUint8(14);
    }
    if (value instanceof Int32Array) {
        writer.writeUint8(15);
    }
    if (value instanceof Float32Array) {
        writer.writeUint8(17);
    }
    if (value instanceof Float64Array) {
        writer.writeUint8(18);
    }
    if (value instanceof DataView) {
        writer.writeUint8(1);
    }
    const buffer = value.buffer.slice(value.byteOffset, value.byteLength);
    writer.writeBuffer(buffer);
}
function initTypedArrayEncoders(encoders, detectors) {
    encoders.set(27, encodeTypedArray);
    detectors.push(detectTypedArray);
}function detectDate(state, value) {
    if (value instanceof Date) {
        return 28;
    }
    return 0;
}
function encodeDate(state, value) {
    const { writer } = state;
    writer.writeFloat64(value.getTime());
}
function initDateEncoders(encoders, detectors) {
    encoders.set(28, encodeDate);
    detectors.push(detectDate);
}function detectRegExp(state, value) {
    if (value instanceof RegExp) {
        return 29;
    }
    return 0;
}
function encodeRegExp(state, value) {
    const { writer } = state;
    const data = value.toString();
    const pattern = data.substring(data.indexOf('/') + 1, data.lastIndexOf('/'));
    writer.writeString(pattern);
    const flags = [value.global, value.ignoreCase, value.multiline, value.sticky];
    writer.writeFlags(flags);
}
function initRegExpEncoders(encoders, detectors) {
    encoders.set(29, encodeRegExp);
    detectors.push(detectRegExp);
}function detectBigInt(state, value) {
    if (typeof value === 'bigint') {
        return 19;
    }
    return 0;
}
function initBigIntEncoders(encoders, detectors) {
    encoders.set(19, (state, value) => state.writer.writeBigInt(value));
    detectors.push(detectBigInt);
}const DEFAULT_ENCODERS = new Map();
const DEFAULT_DETECTORS = [];
initAnyEncoders(DEFAULT_ENCODERS);
initEmptyEncoders(DEFAULT_ENCODERS, DEFAULT_DETECTORS);
initBooleanEncoders(DEFAULT_ENCODERS, DEFAULT_DETECTORS);
initNumberEncoders(DEFAULT_ENCODERS, DEFAULT_DETECTORS);
initBigIntEncoders(DEFAULT_ENCODERS, DEFAULT_DETECTORS);
initStringEncoders(DEFAULT_ENCODERS, DEFAULT_DETECTORS);
initArrayEncoders(DEFAULT_ENCODERS, DEFAULT_DETECTORS);
initSetEncoders(DEFAULT_ENCODERS, DEFAULT_DETECTORS);
initMapEncoders(DEFAULT_ENCODERS, DEFAULT_DETECTORS);
initArrayBufferEncoders(DEFAULT_ENCODERS, DEFAULT_DETECTORS);
initTypedArrayEncoders(DEFAULT_ENCODERS, DEFAULT_DETECTORS);
initDateEncoders(DEFAULT_ENCODERS, DEFAULT_DETECTORS);
initRegExpEncoders(DEFAULT_ENCODERS, DEFAULT_DETECTORS);
initObjectEncoders(DEFAULT_ENCODERS, DEFAULT_DETECTORS);
function detect(state, value) {
    for (const detector of state.detectors) {
        const type = detector(state, value);
        if (type !== 0) {
            return type;
        }
    }
    return 0;
}
function encode(value, options) {
    const writer = new BufferWriter();
    const encoders = options?.encoders ?? DEFAULT_ENCODERS;
    const detectors = options?.detectors ?? DEFAULT_DETECTORS;
    const state = {
        writer,
        detectors,
        encoders,
        detect,
    };
    const encoder = encoders.get(1);
    if (!encoder) {
        throw `Encoder method not found for object: ${value} with type: ${1}`;
    }
    encoder(state, value);
    return state.writer.buffer;
}function initEmptyDecoders(decoders) {
    decoders.set(3, () => undefined);
    decoders.set(2, () => null);
}function initNumberDecoders(decoders) {
    decoders.set(4, () => NaN);
    decoders.set(7, () => Number.POSITIVE_INFINITY);
    decoders.set(8, () => Number.NEGATIVE_INFINITY);
    decoders.set(9, (state) => state.reader.readUint8());
    decoders.set(10, (state) => state.reader.readUint16());
    decoders.set(11, (state) => state.reader.readUint32());
    decoders.set(12, (state) => state.reader.readUintVar());
    decoders.set(13, (state) => state.reader.readInt8());
    decoders.set(14, (state) => state.reader.readInt16());
    decoders.set(15, (state) => state.reader.readInt32());
    decoders.set(16, (state) => state.reader.readIntVar());
    decoders.set(17, (state) => state.reader.readFloat32());
    decoders.set(18, (state) => state.reader.readFloat64());
}function initStringDecoders(decoders) {
    decoders.set(20, (state) => state.reader.readString());
}function decodeStructInfo(state) {
    const { reader } = state;
    const struct = new Map();
    let count = reader.readUintVar();
    while (count--) {
        const name = reader.readString();
        const type = reader.readUint8();
        struct.set(name, type);
    }
    return struct;
}
function decodeStruct(state, struct) {
    const value = {};
    for (const property of struct) {
        const [name, type] = property;
        const decoder = state.decoders.get(type);
        if (!decoder) {
            throw `Decoder method not found for object type: ${type} in struct decoding`;
        }
        value[name] = decoder(state);
    }
    return value;
}function decodeArray(state) {
    const { reader, decoders } = state;
    const value = [];
    let groups = reader.readUintVar();
    let i = 0;
    while (groups--) {
        const type = reader.readUint8();
        let count = reader.readUintVar();
        if (isBooleanType(type)) {
            const bitset = reader.readBitset(count);
            let j = 0;
            while (j < count) {
                value[i++] = bitset[j++];
            }
        }
        else if (type === 23) {
            const struct = decodeStructInfo(state);
            while (count--) {
                const item = decodeStruct(state, struct);
                value[i++] = item;
            }
        }
        else if (type === 3) {
            i += count;
        }
        else {
            const decoder = decoders.get(type);
            if (!decoder) {
                throw `Decoder method not found for object type: ${type} in array decoding`;
            }
            while (count--) {
                const item = decoder(state);
                value[i++] = item;
            }
        }
    }
    return value;
}
function initArrayDecoders(decoders) {
    decoders.set(21, decodeArray);
}function initBooleanDecoders(decoders) {
    decoders.set(5, () => false);
    decoders.set(6, () => true);
}function decodeObject(state) {
    const { reader, decoders } = state;
    let count = reader.readUintVar();
    const decoder = decoders.get(1);
    if (!decoder) {
        throw `Decoder method not found for object type: ${1} in object decoding`;
    }
    const objectValue = {};
    while (count--) {
        const key = reader.readString();
        const value = decoder(state);
        objectValue[key] = value;
    }
    return objectValue;
}
function initObjectDecoders(decoders) {
    decoders.set(22, decodeObject);
}function decodeAny(state) {
    const type = state.reader.readUint8();
    const decoder = state.decoders.get(type);
    if (!decoder) {
        throw `Decoder method not found for object type: ${type}`;
    }
    return decoder(state);
}
function initAnyDecoders(decoders) {
    decoders.set(1, decodeAny);
}function decodeSet(state) {
    const array = decodeArray(state);
    return new Set(array);
}
function initSetDecoders(decoders) {
    decoders.set(24, decodeSet);
}function decodeMap(state) {
    const keys = decodeArray(state);
    const values = decodeArray(state);
    const map = new Map();
    for (let i = 0; i < keys.length; i++) {
        map.set(keys[i], values[i]);
    }
    return map;
}
function initMapDecoders(decoders) {
    decoders.set(25, decodeMap);
}function decodeArrayBuffer(state) {
    const { reader } = state;
    const value = reader.readBuffer();
    return value;
}
function initArrayBufferDecoders(decoders) {
    decoders.set(26, decodeArrayBuffer);
}function decodeTypedArray(state) {
    const { reader } = state;
    const type = reader.readUint8();
    const buffer = reader.readBuffer();
    switch (type) {
        case 9:
            return new Uint8Array(buffer);
        case 10:
            return new Uint16Array(buffer);
        case 11:
            return new Uint32Array(buffer);
        case 13:
            return new Int8Array(buffer);
        case 14:
            return new Int16Array(buffer);
        case 15:
            return new Int32Array(buffer);
        case 17:
            return new Float32Array(buffer);
        case 18:
            return new Float64Array(buffer);
        case 1:
            return new DataView(buffer);
        default:
            throw `Unknown typed array type: ${type}`;
    }
}
function initTypedArrayDecoders(decoders) {
    decoders.set(27, decodeTypedArray);
}function decodeDate(state) {
    const { reader } = state;
    return new Date(reader.readFloat64());
}
function initDateDecoders(decoders) {
    decoders.set(28, decodeDate);
}const FLAGS = ['g', 'i', 'm', 'y'];
function decodeRegExp(state) {
    const { reader } = state;
    const pattern = reader.readString();
    const flags = reader.readFlags(4);
    const flagsString = flags.map((flag, index) => (flag ? FLAGS[index] : '')).join('');
    const value = new RegExp(pattern, flagsString);
    return value;
}
function initRegExpDecoders(decoders) {
    decoders.set(29, decodeRegExp);
}function initBigIntDecoders(decoders) {
    decoders.set(19, (state) => state.reader.readBigInt());
}const DEFAULT_DECODERS = new Map();
initAnyDecoders(DEFAULT_DECODERS);
initEmptyDecoders(DEFAULT_DECODERS);
initBooleanDecoders(DEFAULT_DECODERS);
initNumberDecoders(DEFAULT_DECODERS);
initBigIntDecoders(DEFAULT_DECODERS);
initStringDecoders(DEFAULT_DECODERS);
initArrayDecoders(DEFAULT_DECODERS);
initSetDecoders(DEFAULT_DECODERS);
initMapDecoders(DEFAULT_DECODERS);
initArrayBufferDecoders(DEFAULT_DECODERS);
initTypedArrayDecoders(DEFAULT_DECODERS);
initDateDecoders(DEFAULT_DECODERS);
initRegExpDecoders(DEFAULT_DECODERS);
initObjectDecoders(DEFAULT_DECODERS);
function decode(buffer, options) {
    const reader = new BufferReader(buffer);
    const decoders = options?.decoders ?? DEFAULT_DECODERS;
    const state = {
        reader,
        decoders,
    };
    const decoder = decoders.get(1);
    if (!decoder) {
        throw `Decoder method not found for object type: ${1}`;
    }
    const value = decoder(state);
    return value;
}exports.DEFAULT_DECODERS=DEFAULT_DECODERS;exports.DEFAULT_DETECTORS=DEFAULT_DETECTORS;exports.DEFAULT_ENCODERS=DEFAULT_ENCODERS;exports.decode=decode;exports.encode=encode;exports.isBooleanType=isBooleanType;exports.isFloatType=isFloatType;exports.isIntegerType=isIntegerType;exports.isNumberType=isNumberType;Object.defineProperty(exports,'__esModule',{value:true});return exports;})({});//# sourceMappingURL=xobj-core.min.js.map
